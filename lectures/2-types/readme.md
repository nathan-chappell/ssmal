# Lecture 2: Types

## Overview

Practically speaking, a *type* is metadata associated to a variable or parameter in a program.
Proper use of *type annotations* and a *type checker* can help ensure program correctness.
Different *type systems* have different expressive power - some are even turing complete.
Some tools are capable of *type inference,* which can reduce tedious and error prone coding practices.
Some languages offer the ability to read, and even modify, information about types *at runtime.*  Such techniques are broadly called *reflection.*

* Examples...

TODO: come up with a "framework" for demonstrating the type systems I want to show...

curry-howard

* Basic definitions, problems (checking, inference)
* Mathematical theory of simple types (trees, functions over strings)
* Technical and intersting aspects of typing in python
* Some theoretical / conceptualization of the interesting typing issues
* *BONUS* Complexity, Decidability

## Polymorphism
* ad-hoc and dependent types
* subtyping
* virtual methods and the coproduct

## Recursive Types
* basics...




# Assignment:

* Consider the following from **ECMA 335 (5th edition, December 2010) section 9.2**:

![ecma-335-9.2_1](./img/ecma-335-9.2_1.png)
![ecma-335-9.2_2](./img/ecma-335-9.2_2.png)

![ecma-335-9.2-example-1](./img/ecma-335-9.2-example-1.png)
![ecma-335-9.2-example-2](./img/ecma-335-9.2-example-2.png)
![ecma-335-9.2-example-3](./img/ecma-335-9.2-example-3.png)

## Your task:

<!-- TODO: come up with something to do -->